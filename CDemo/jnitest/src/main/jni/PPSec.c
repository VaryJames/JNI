#ifndef __INCLUDED_PPSEC__
#define __INCLUDED_PPSEC__
#ifdef __cplusplus
extern "C" {
#endif

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdio.h>
#include <sys/types.h>
/* Header for class com_tools_client */

#include <android/log.h>

#define LOG_TAG "Hong******"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)

#include <string.h>
#include <inttypes.h>
#include <sys/time.h>
#include "md5.h"

jstring getServerUrl(JNIEnv *env, jclass obj)
{
    return (*env)->NewStringUTF(env,"http://192.168.22.84:8081/");
}

jint decrypt(JNIEnv *env, jclass obj, jbyteArray inData, jbyteArray keyBytes, jobject joutdata){

//    LOGI("decrypt %d",1);

    char* inDataCp = (char*)(*env)->GetByteArrayElements(env,inData, 0);
    char* keyDataCp = (char*)(*env)->GetByteArrayElements(env,keyBytes,0);

    int inSize = (int)(*env)->GetArrayLength(env, inData);
//    LOGI("decrypt inSize = %d",inSize);

    int keySize = (int)(*env)->GetArrayLength(env, keyBytes);
//    LOGI("decrypt keySize = %d",keySize);

//    if(keySize !=8){
//        LOGI("decrypt keySize error");
//    }
//
//    if(inSize %16 !=0){
//        LOGI("decrypt inData error");
//    }

    void SetKey(char KeyIn[8]);
    void KickDes(char MesOut[8],char MesIn[16]);

    SetKey(keyDataCp);
    char outChars[8] ;
    KickDes(outChars,inDataCp);

    jbyteArray outByteArray;

    outByteArray = (*env)-> NewByteArray(env, 8);
    (*env)->SetByteArrayRegion(env, outByteArray, 0, 8, (jbyte*)outChars);

    jclass cls = (*env)->GetObjectClass(env, joutdata);
    jmethodID mid;
    mid = (*env)->GetMethodID(env, cls, "setByteData", "([B)V");
    (*env)->CallVoidMethod(env, joutdata, mid, outByteArray);

//    mid = (*env)->GetMethodID(env, cls, "setDataLen", "(I)V");
//    (*env)->CallVoidMethod(env, joutdata, mid, 16);

    return 0;

}

jint encrypt(JNIEnv *env, jclass obj, jbyteArray inData, jbyteArray keyBytes, jobject joutdata){
//    LOGI("encrypt %d",1);

    char* inDataCp = (char*)(*env)->GetByteArrayElements(env,inData, 0);
    char* keyDataCp = (char*)(*env)->GetByteArrayElements(env,keyBytes,0);

    int inSize = (int)(*env)->GetArrayLength(env,inData);
//    LOGI("encrypt inSize = %d",inSize);

    int keySize = (int)(*env)->GetArrayLength(env,keyBytes);
//    LOGI("encrypt keySize = %d",keySize);

//    if(keySize !=8){
//        LOGI("encrypt keySize error");
//    }
//
//    if(inSize %8 !=0){
//        LOGI("encrypt inData error");
//    }

    void SetKey(char KeyIn[8]);
    void PlayDes(char MesOut[16],char MesIn[8]);

    SetKey(keyDataCp);

//    LOGI("encrypt SetKey %d",2);

    char outChars[16] ;

    int i;
    PlayDes(outChars,inDataCp);
//    LOGI("encrypt PlayDes %d",3);

    jbyteArray outByteArray;

    outByteArray = (*env)-> NewByteArray(env, 16);
//    LOGI("encrypt %d",4);
    (*env)->SetByteArrayRegion(env, outByteArray, 0, 16, (jbyte*)outChars);

//    LOGI("encrypt %d",5);

    jclass cls = (*env)->GetObjectClass(env, joutdata);
    jmethodID mid;

//    LOGI("encrypt %d",6);

    mid = (*env)->GetMethodID(env, cls, "setByteData", "([B)V");
    (*env)->CallVoidMethod(env, joutdata, mid, outByteArray);

//    LOGI("encrypt %d",7);

//    mid = (*env)->GetMethodID(env, cls, "setDataLen", "(I)V");
//    (*env)->CallVoidMethod(env, joutdata, mid, 8);
//
//    LOGI("encrypt %d",8);

    return 0;

}

jstring getMd5(JNIEnv *env, jobject obj, jint len,jstring str){

    char* jstringTostring(JNIEnv* env, jstring jstr);
    jstring stoJstring(JNIEnv* env, const char* pat);
    void getMD5(unsigned char *input,unsigned int len,unsigned char digest[16]);

    LOGI("getMd5 %d",1);

    LOGI("getMd5 str = %s",(unsigned char *)jstringTostring(env,str));

    LOGI("getMd5 len = %d",len);

    unsigned char decrypt[16];

    LOGI("getMd5 %d",2);

    unsigned int md5Len = len;

    LOGI("getMd5 %d",3);

    unsigned char *input = (unsigned char *)jstringTostring(env,str);

    LOGI("getMd5 %d",4);
    getMD5(input,md5Len,decrypt);

    char out[32] ;
    int i;
    for(i=0;i<16;i++){
        out[2*i] = decrypt[i]&0x00FF;
        out[2*i+1] = decrypt[i]>>4;

        LOGI("getMd5 %c",out[2*i]);
        LOGI("getMd5 %c",out[2*i+1]);
    }

    LOGI("getMd5 %d",5);

    LOGI("getMd5 decrypt = %s",decrypt);

    char *md5=(char *)malloc((32 + 1) * sizeof(char));

    LOGI("getMd5 %d",6);

    if(md5 == NULL)
    {
      LOGI("malloc failed.");
      return NULL;
    }

    for(i=0; i<16; i++)
      {
       sprintf(&md5[i*2], "%02x", decrypt[i]);
      }

    LOGI("getMd5 md5 = %s",md5);

    return (jstring)stoJstring(env,md5);

}

char* jstringTostring(JNIEnv* env, jstring jstr)
{
    LOGI("jstringTostring %d",1);
    char* rtn = NULL;

    jclass clsstring = (*env)->FindClass(env, "java/lang/String");
    jstring strencode = (*env)->NewStringUTF(env,"utf-8");
    jmethodID mid = (*env)->GetMethodID(env,clsstring, "getBytes", "(Ljava/lang/String;)[B");

    LOGI("jstringTostring %d",2);

    jbyteArray barr= (jbyteArray)(*env)->CallObjectMethod(env,jstr, mid, strencode);
    jsize alen = (*env)->GetArrayLength(env,barr);
    jbyte* ba = (*env)->GetByteArrayElements(env,barr, JNI_FALSE);
    if (alen > 0)
    {
        rtn = (char*)malloc(alen + 1);
        LOGI("jstringTostring %d",3);
        memcpy(rtn, ba, alen);
        LOGI("jstringTostring %d",4);
        rtn[alen] = 0;
    }

    LOGI("jstringTostring %d",5);

    (*env)->ReleaseByteArrayElements(env,barr, ba, 0);
    LOGI("jstringTostring %d",6);
    return rtn;
}

jstring stoJstring(JNIEnv* env, const char* pat)
{
    LOGI("stoJstring %d",1);
    LOGI("stoJstring pat = %s",pat);
    jclass strClass = (*env)->FindClass(env,"java/lang/String");
    LOGI("stoJstring %d",2);
    jmethodID ctorID = (*env)->GetMethodID(env,strClass, "<init>", "([BLjava/lang/String;)V");
    LOGI("stoJstring %d",3);
    jbyteArray bytes = (*env)->NewByteArray(env,strlen(pat));
    LOGI("stoJstring %d",4);
    (*env)->SetByteArrayRegion(env,bytes, 0, strlen(pat), (jbyte*)pat);
    LOGI("stoJstring %d",5);
    jstring encoding = (*env)->NewStringUTF(env,"utf-8");
    LOGI("stoJstring %d",6);
    return (jstring)((*env)->NewObject(env,strClass, ctorID, bytes, encoding));
}

const static char* ppclasses[] = {
    "com/liuhong/app/NativeUtil",
};
const static JNINativeMethod mtCmd[] = {
    {"getServerUrl", "()Ljava/lang/String;", (jstring *) getServerUrl},
    {"getMd5", "(ILjava/lang/String;)Ljava/lang/String;", (jstring *) getMd5},
    {"encrypt","([B[BLcom/liuhong/app/NativeData;)I",(jint *) encrypt},
    {"decrypt","([B[BLcom/liuhong/app/NativeData;)I",(jint *) decrypt}
};

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {
    // Get JNI Env for all function calls
    JNIEnv* env;
    if ((*vm)->GetEnv(vm, (void **) &env, JNI_VERSION_1_6) != JNI_OK) {
       return -1;
    }
    
    jclass nativeCls = (*env)->FindClass(env, ppclasses[0]);
    if (nativeCls == NULL) {
        return -1;
    }

    // Register native method
    if ((*env)->RegisterNatives(env, nativeCls, mtCmd, sizeof(mtCmd) / sizeof(mtCmd[0]))) {
        return -1;
    }

    return JNI_VERSION_1_6;
}

#ifdef __cplusplus
}
#endif
#endif
